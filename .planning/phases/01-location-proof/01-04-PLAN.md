---
phase: 01-location-proof
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: [server/index.js]
autonomous: true
domain: nodejs-backend
---

<objective>
Implement Models/Providers aggregation from all search roots with source tracking.

Purpose: Enable discovery of models and providers from all opencode.json configs, not just the active one.
Output: New `/api/models` endpoint aggregating models from all sources.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@server/index.js

## Current State Analysis

From server/index.js review:

**Current Implementation:**
- `loadConfig()` (lines 862-875): Loads ONLY the active config file
- Models/providers come from `config.model.providers` or `config.providers`
- No aggregation from multiple configs

**Migration Context:**
From AGENTS.md: "Config migration: root `providers` auto-moved to `model.providers`"
- Old: `config.providers`
- New: `config.model.providers`

**What's Needed:**
- Aggregate providers/models from ALL opencode.json files across search roots
- Support both old (`providers`) and new (`model.providers`) structure
- Add source field: 'json-config' with configPath
- Provide unified view of all available models

## Model/Provider Structure

```json
{
  "model": {
    "providers": {
      "openai": {
        "apiKey": "...",
        "models": ["gpt-4", "gpt-3.5-turbo"]
      }
    }
  }
}
```

Or legacy:
```json
{
  "providers": {
    "openai": { ... }
  }
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create aggregateModels function</name>
  <files>server/index.js</files>
  <action>
Add `aggregateModels()` function.

Function should:
1. Get all search roots via getSearchRoots()
2. Initialize Map for providers (providerName -> providerConfig)
3. For each root:
   - Check for opencode.json existence
   - Parse config
   - Extract providers from EITHER:
     - config.model.providers (new structure)
     - config.providers (legacy structure)
   - For each provider found:
     - Add to map with source: 'json-config'
     - Include configPath: root
     - If provider already exists, keep first (lower priority roots)
4. Transform to array format:
   ```javascript
   {
     name: providerName,           // e.g., "openai"
     config: providerConfig,       // { apiKey, models, ... }
     source: 'json-config',
     configPath: rootPath
   }
   ```
5. Return array of all providers

Priority:
- Active config (first in search roots) has highest priority
- Later configs fill in missing providers
- Same provider in multiple configs: first wins

Note: Unlike skills/plugins, models are ONLY in JSON config (no directory structure).
  </action>
  <verify>grep -n "aggregateModels" server/index.js | head -5</verify>
  <done>Function exists and aggregates providers from all configs</done>
</task>

<task type="auto">
  <name>Task 2: Create /api/models endpoint</name>
  <files>server/index.js</files>
  <action>
Add `GET /api/models` endpoint (after /api/plugins).

Endpoint should:
```javascript
app.get('/api/models', (req, res) => {
  try {
    const providers = aggregateModels();
    
    // Flatten to individual models if config includes model lists
    const allModels = [];
    for (const provider of providers) {
      if (provider.config.models && Array.isArray(provider.config.models)) {
        // Provider has explicit model list
        for (const model of provider.config.models) {
          allModels.push({
            id: typeof model === 'string' ? model : model.id,
            provider: provider.name,
            providerConfig: provider.config,
            ...((typeof model === 'object' ? model : {}))
          });
        }
      } else {
        // Provider without explicit model list
        allModels.push({
          id: `${provider.name}/default`,
          provider: provider.name,
          providerConfig: provider.config
        });
      }
    }
    
    res.json({ 
      providers,
      models: allModels 
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});
```

Return format:
- providers: Array of provider configs with source
- models: Flattened array of individual models with provider info
  </action>
  <verify>curl -s http://localhost:1920/api/models | jq '.providers[0] | {name, source}'</verify>
  <done>Endpoint returns providers and models with source tracking</done>
</task>

</tasks>

<verification>
Before declaring complete:
- [ ] Server starts without errors
- [ ] Test endpoint: `curl -s http://localhost:1920/api/models`
- [ ] Verify providers array has source field for each
- [ ] Verify models array includes provider info
- [ ] Test with multiple configs: Create provider in secondary config location
- [ ] Verify provider from secondary location appears in response
</verification>

<success_criteria>
- aggregateModels() function created aggregating from all search roots
- GET /api/models endpoint returns providers and models
- Each provider has source field indicating origin
- Supports both legacy (config.providers) and new (config.model.providers) structure
- Active config providers take priority over secondary configs
- Response includes both providers array and flattened models array
- Server starts and responds correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-location-proof/01-04-SUMMARY.md`
</output>
